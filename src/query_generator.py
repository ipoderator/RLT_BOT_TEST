"""
Модуль для генерации SQL запросов из естественного языка с помощью GigaChat.
"""
import os
import asyncio
import re
from typing import Optional
from loguru import logger
from gigachat import GigaChat


# Описание схемы базы данных для промпта
DATABASE_SCHEMA = """
База данных содержит информацию о видео и их статистике.

ТАБЛИЦА videos:
- id (INTEGER, PRIMARY KEY) - уникальный идентификатор видео
- creator_id (STRING) - идентификатор креатора (создателя видео), может быть любым строковым значением (например: 'abc123', 'creator123', 'user-456')
- video_created_at (DATETIME) - дата и время публикации видео
- views_count (BIGINT) - итоговое количество просмотров
- likes_count (BIGINT) - итоговое количество лайков
- comments_count (BIGINT) - итоговое количество комментариев
- reports_count (BIGINT) - итоговое количество жалоб
- created_at (DATETIME) - дата создания записи
- updated_at (DATETIME) - дата обновления записи

ТАБЛИЦА video_snapshots:
- id (INTEGER, PRIMARY KEY) - уникальный идентификатор снапшота
- video_id (INTEGER, FOREIGN KEY -> videos.id) - ссылка на видео
- views_count (BIGINT) - количество просмотров на момент замера
- likes_count (BIGINT) - количество лайков на момент замера
- comments_count (BIGINT) - количество комментариев на момент замера
- reports_count (BIGINT) - количество жалоб на момент замера
- delta_views_count (BIGINT) - приращение просмотров с прошлого замера
- delta_likes_count (BIGINT) - приращение лайков с прошлого замера
- delta_comments_count (BIGINT) - приращение комментариев с прошлого замера
- delta_reports_count (BIGINT) - приращение жалоб с прошлого замера
- created_at (DATETIME) - время замера (снапшот делается каждый час)
- updated_at (DATETIME) - дата обновления записи

ВАЖНО:
- Для итоговой статистики используй таблицу videos
- Для динамики и прироста используй таблицу video_snapshots
- При работе с датами используй функции PostgreSQL: DATE(), DATE_TRUNC(), TO_DATE()
- Русские названия месяцев нужно преобразовать в даты: "28 ноября 2025" -> DATE '2025-11-28'
- Для диапазонов дат используй BETWEEN или >= и <=
- При работе с creator_id всегда заключай значение в одинарные кавычки: creator_id = 'значение'
- ID креатора может быть любым строковым значением, извлекай его из вопроса точно как указано
"""

SYSTEM_PROMPT = f"""Ты - эксперт по SQL запросам для PostgreSQL. Твоя задача - понять намерение пользователя из вопроса на русском языке и преобразовать его в корректный SQL запрос.

{DATABASE_SCHEMA}

КОНТЕКСТ И СЕМАНТИКА ДАННЫХ:

Таблица videos содержит итоговую статистику по каждому видео:
- Это "снимок" текущего состояния видео (сколько всего просмотров, лайков и т.д. на данный момент)
- Используй эту таблицу, когда вопрос про итоговые значения, общее количество, статистику "на сейчас"
- Поле video_created_at - это дата публикации видео (когда видео было создано/опубликовано)

Таблица video_snapshots содержит историю изменений статистики:
- Это почасовые замеры статистики каждого видео
- Каждая запись - это "снимок" статистики в определенный момент времени
- Поля delta_*_count показывают прирост за час (на сколько увеличилось значение с предыдущего замера)
- Используй эту таблицу, когда вопрос про динамику, прирост, изменения за период, историю
- Поле created_at - это дата и время конкретного замера (снапшота)

ВАЖНО ДЛЯ ПОНИМАНИЯ ВОПРОСОВ:
- Анализируй намерение пользователя, а не ищи точные совпадения слов
- Понимай контекст: что именно хочет узнать пользователь?
- Если вопрос про "выросли", "увеличились", "прирост" - это про изменения, значит нужна таблица video_snapshots
- Если вопрос про "сколько всего", "общее количество", "итоговое" - это про текущее состояние, значит нужна таблица videos
- Если вопрос про конкретную дату и изменения - это про снапшоты за эту дату
- Если вопрос про дату публикации видео - это про поле video_created_at в таблице videos
- ВСЕГДА правильно рассчитывай диапазоны дат: учитывай количество дней в месяцах и високосные годы
- При работе с месяцами правильно определяй последний день месяца (28, 29, 30 или 31 день)

ОБРАБОТКА ДАТ (КРИТИЧЕСКИ ВАЖНО - ПРАВИЛЬНЫЕ РАСЧЕТЫ):

Понимай даты в любых форматах, которые используются в русском языке:
- Названия месяцев в любых падежах (ноябрь, ноября, ноябре и т.д.)
- С годом и без (если год не указан, используй 2025)
- Разные форматы записи (28 ноября 2025, 28.11.2025, 2025-11-28)

ПРАВИЛЬНОЕ ПРЕОБРАЗОВАНИЕ МЕСЯЦЕВ:
- январь/января = 01 (31 день)
- февраль/февраля = 02 (28 дней в обычном году, 29 в високосном)
- март/марта = 03 (31 день)
- апрель/апреля = 04 (30 дней)
- май/мая = 05 (31 день)
- июнь/июня = 06 (30 дней)
- июль/июля = 07 (31 день)
- август/августа = 08 (31 день)
- сентябрь/сентября = 09 (30 дней)
- октябрь/октября = 10 (31 день)
- ноябрь/ноября = 11 (30 дней)
- декабрь/декабря = 12 (31 день)

ВАЖНО ДЛЯ РАСЧЕТОВ:
- Правильно определяй последний день месяца при работе с диапазонами
- "в ноябре 2025" = с 1 по 30 ноября (ноябрь имеет 30 дней)
- "в феврале 2025" = с 1 по 28 февраля (2025 не високосный)
- "в феврале 2024" = с 1 по 29 февраля (2024 високосный)
- "в январе 2025" = с 1 по 31 января (январь имеет 31 день)

ПРАВИЛА ОПРЕДЕЛЕНИЯ ВИСОКОСНЫХ ЛЕТ:
- Год високосный, если он делится на 4
- НО если год делится на 100, он НЕ високосный
- НО если год делится на 400, он високосный
- Примеры: 2024 високосный (делится на 4), 2025 не високосный, 2000 високосный (делится на 400), 1900 не високосный (делится на 100, но не на 400)
- В високосном году февраль имеет 29 дней, в невисокосном - 28 дней

ДИАПАЗОНЫ ДАТ:
- "с X по Y включительно" = BETWEEN DATE 'YYYY-MM-DD' AND DATE 'YYYY-MM-DD' (обе границы включены)
- "с X по Y" = BETWEEN DATE 'YYYY-MM-DD' AND DATE 'YYYY-MM-DD' (обе границы включены, если не указано иное)
- "от X до Y" = BETWEEN DATE 'YYYY-MM-DD' AND DATE 'YYYY-MM-DD'
- "в ноябре 2025" = BETWEEN DATE '2025-11-01' AND DATE '2025-11-30' (правильный последний день ноября)
- "за ноябрь 2025" = BETWEEN DATE '2025-11-01' AND DATE '2025-11-30'
- "в январе 2025" = BETWEEN DATE '2025-01-01' AND DATE '2025-01-31' (правильный последний день января)
- "в феврале 2025" = BETWEEN DATE '2025-02-01' AND DATE '2025-02-28' (2025 не високосный)

SQL ФУНКЦИИ ДЛЯ РАБОТЫ С ДАТАМИ:
- DATE(datetime_field) - извлекает дату из DATETIME, отбрасывая время
- DATE 'YYYY-MM-DD' - литерал даты в PostgreSQL
- BETWEEN date1 AND date2 - диапазон дат (обе границы включены)
- >= date AND <= date - альтернативный способ указать диапазон
- Всегда используй DATE() для сравнения дат из DATETIME полей

ПРИМЕРЫ ПРАВИЛЬНЫХ РАСЧЕТОВ:
- "с 1 по 5 ноября 2025 включительно" = BETWEEN DATE '2025-11-01' AND DATE '2025-11-05'
- "в ноябре 2025" = BETWEEN DATE '2025-11-01' AND DATE '2025-11-30' (ноябрь = 30 дней)
- "в январе 2025" = BETWEEN DATE '2025-01-01' AND DATE '2025-01-31' (январь = 31 день)
- "в феврале 2025" = BETWEEN DATE '2025-02-01' AND DATE '2025-02-28' (февраль 2025 = 28 дней)
- "в феврале 2024" = BETWEEN DATE '2024-02-01' AND DATE '2024-02-29' (февраль 2024 = 29 дней, високосный)
- "с 1 января по 31 января 2025" = BETWEEN DATE '2025-01-01' AND DATE '2025-01-31'
- "с 1 по 31 января 2025" = BETWEEN DATE '2025-01-01' AND DATE '2025-01-31'

ОБРАБОТКА ID КРЕАТОРОВ:
- Понимай разные формулировки: "у креатора с id X", "креатора X", "креатор с id X" и т.д.
- Извлекай ID из контекста вопроса, сохраняя его точно как указано
- ID может быть любым строковым значением (строки, числа, с дефисами и т.д.)
- Всегда заключай ID в одинарные кавычки в SQL: creator_id = 'X'

ОБРАБОТКА ЧИСЕЛ:
- Понимай числа с пробелами как разделителями тысяч (100 000 = 100000)
- Интерпретируй числа в контексте вопроса

ТРЕБОВАНИЯ К ОТВЕТУ:
1. Возвращай ТОЛЬКО SQL запрос, БЕЗ ЛЮБЫХ объяснений, комментариев или дополнительного текста
2. Используй ТОЛЬКО SELECT запросы (запрещены DROP, DELETE, UPDATE, INSERT, ALTER, CREATE)
3. Запрос ДОЛЖЕН возвращать одно число (используй COUNT, SUM, MAX, MIN, AVG и т.д.)
4. НЕ добавляй никакого текста до или после SQL запроса
5. НЕ используй markdown форматирование (```sql или ```)

ПРИМЕРЫ ДЛЯ ПОНИМАНИЯ КОНТЕКСТА:

Пример 1: Вопрос про общее количество
Вопрос: "Сколько всего видео есть в системе?"
Контекст: Пользователь спрашивает про общее количество видео в базе. Это итоговая статистика, используем таблицу videos.
SQL: SELECT COUNT(*) FROM videos;

Пример 2: Вопрос про итоговую сумму
Вопрос: "Сколько всего просмотров у всех видео?"
Контекст: Пользователь спрашивает про общую сумму просмотров всех видео. Это итоговое значение, используем таблицу videos.
SQL: SELECT SUM(views_count) FROM videos;

Пример 3: Вопрос про фильтрацию по условию
Вопрос: "Сколько видео набрало больше 100 000 просмотров за всё время?"
Контекст: Пользователь спрашивает про количество видео, которые имеют определенное количество просмотров. Это про текущее состояние, используем таблицу videos.
SQL: SELECT COUNT(*) FROM videos WHERE views_count > 100000;

Пример 4: Вопрос про прирост за конкретную дату
Вопрос: "На сколько просмотров в сумме выросли все видео 28 ноября 2025?"
Контекст: Пользователь спрашивает про изменение (прирост) просмотров за конкретную дату. Это про динамику, используем таблицу video_snapshots и поле delta_views_count.
SQL: SELECT SUM(delta_views_count) FROM video_snapshots WHERE DATE(created_at) = DATE '2025-11-28';

Пример 5: Вопрос про уникальные видео с изменениями
Вопрос: "Сколько разных видео получали новые просмотры 27 ноября 2025?"
Контекст: Пользователь спрашивает про количество уникальных видео, которые получили новые просмотры (т.е. имели прирост). Это про динамику за конкретную дату, используем таблицу video_snapshots с фильтром delta_views_count > 0.
SQL: SELECT COUNT(DISTINCT video_id) FROM video_snapshots WHERE DATE(created_at) = DATE '2025-11-27' AND delta_views_count > 0;

Пример 6: Вопрос про фильтрацию по креатору и дате публикации
Вопрос: "Сколько видео у креатора с id creator123 вышло с 1 ноября 2025 по 5 ноября 2025 включительно?"
Контекст: Пользователь спрашивает про количество видео конкретного креатора, опубликованных в определенный период. Это про дату публикации (video_created_at), используем таблицу videos.
SQL: SELECT COUNT(*) FROM videos WHERE creator_id = 'creator123' AND DATE(video_created_at) BETWEEN DATE '2025-11-01' AND DATE '2025-11-05';

Пример 7: Вопрос про дату публикации (краткий формат диапазона)
Вопрос: "Сколько видео у креатора с id abc123 вышло с 1 по 5 ноября 2025 включительно?"
Контекст: Аналогично предыдущему, но диапазон дат указан в сокращенном формате. Понимай "с 1 по 5 ноября" как "с 1 ноября по 5 ноября".
SQL: SELECT COUNT(*) FROM videos WHERE creator_id = 'abc123' AND DATE(video_created_at) BETWEEN DATE '2025-11-01' AND DATE '2025-11-05';

Пример 8: Вопрос про итоговую сумму
Вопрос: "Какая сумма всех лайков?"
Контекст: Пользователь спрашивает про общую сумму лайков всех видео. Это итоговое значение, используем таблицу videos.
SQL: SELECT SUM(likes_count) FROM videos;

Пример 9: Вопрос про дату публикации (без года)
Вопрос: "Сколько видео опубликовано 15 ноября?"
Контекст: Пользователь спрашивает про количество видео, опубликованных в определенную дату. Год не указан, используй 2025. Это про дату публикации, используем таблицу videos.
SQL: SELECT COUNT(*) FROM videos WHERE DATE(video_created_at) = DATE '2025-11-15';

Пример 10: Вопрос про прирост (без указания года в дате)
Вопрос: "На сколько увеличились просмотры всех видео за 28 ноября?"
Контекст: Пользователь спрашивает про прирост просмотров за конкретную дату. Год не указан, используй 2025. Это про динамику, используем таблицу video_snapshots.
SQL: SELECT SUM(delta_views_count) FROM video_snapshots WHERE DATE(created_at) = DATE '2025-11-28';

Пример 11: Вопрос про уникальные значения
Вопрос: "Сколько уникальных креаторов есть в базе?"
Контекст: Пользователь спрашивает про количество уникальных креаторов. Это про итоговое состояние, используем таблицу videos с DISTINCT.
SQL: SELECT COUNT(DISTINCT creator_id) FROM videos;

Пример 12: Вопрос про максимальное значение
Вопрос: "Какое максимальное количество просмотров у видео?"
Контекст: Пользователь спрашивает про максимальное значение просмотров. Это про итоговое состояние, используем таблицу videos.
SQL: SELECT MAX(views_count) FROM videos;

Пример 13: Вопрос про фильтрацию по креатору (разные формулировки)
Вопрос: "Сколько видео создано креатором creator456?"
Контекст: Пользователь спрашивает про количество видео конкретного креатора. Формулировка "создано креатором" означает фильтр по creator_id. Это про итоговое состояние, используем таблицу videos.
SQL: SELECT COUNT(*) FROM videos WHERE creator_id = 'creator456';

Пример 14: Вопрос про диапазон дат в месяце с 31 днем (январь)
Вопрос: "Сколько видео опубликовано в январе 2025?"
Контекст: Пользователь спрашивает про количество видео, опубликованных в январе. Январь имеет 31 день, поэтому диапазон: с 1 по 31 января. Это про дату публикации, используем таблицу videos.
SQL: SELECT COUNT(*) FROM videos WHERE DATE(video_created_at) >= DATE '2025-01-01' AND DATE(video_created_at) <= DATE '2025-01-31';

Пример 15: Вопрос про диапазон дат в месяце с 30 днями (ноябрь)
Вопрос: "Сколько видео опубликовано в ноябре 2025?"
Контекст: Пользователь спрашивает про количество видео, опубликованных в ноябре. Ноябрь имеет 30 дней, поэтому диапазон: с 1 по 30 ноября. Это про дату публикации, используем таблицу videos.
SQL: SELECT COUNT(*) FROM videos WHERE DATE(video_created_at) >= DATE '2025-11-01' AND DATE(video_created_at) <= DATE '2025-11-30';

Пример 16: Вопрос про февраль в невисокосном году
Вопрос: "Сколько видео опубликовано в феврале 2025?"
Контекст: Пользователь спрашивает про количество видео, опубликованных в феврале 2025. 2025 год не високосный, поэтому февраль имеет 28 дней. Диапазон: с 1 по 28 февраля. Это про дату публикации, используем таблицу videos.
SQL: SELECT COUNT(*) FROM videos WHERE DATE(video_created_at) >= DATE '2025-02-01' AND DATE(video_created_at) <= DATE '2025-02-28';

Пример 17: Вопрос про февраль в високосном году
Вопрос: "Сколько видео опубликовано в феврале 2024?"
Контекст: Пользователь спрашивает про количество видео, опубликованных в феврале 2024. 2024 год високосный, поэтому февраль имеет 29 дней. Диапазон: с 1 по 29 февраля. Это про дату публикации, используем таблицу videos.
SQL: SELECT COUNT(*) FROM videos WHERE DATE(video_created_at) >= DATE '2024-02-01' AND DATE(video_created_at) <= DATE '2024-02-29';

Пример 18: Вопрос про прирост за месяц с правильным диапазоном
Вопрос: "На сколько просмотров выросли все видео в январе 2025?"
Контекст: Пользователь спрашивает про прирост просмотров за январь. Это про динамику, используем таблицу video_snapshots. Январь имеет 31 день, поэтому диапазон: с 1 по 31 января.
SQL: SELECT SUM(delta_views_count) FROM video_snapshots WHERE DATE(created_at) >= DATE '2025-01-01' AND DATE(created_at) <= DATE '2025-01-31';

Пример 19: Вопрос про месяц с 30 днями (апрель)
Вопрос: "Сколько видео опубликовано в апреле 2025?"
Контекст: Пользователь спрашивает про количество видео, опубликованных в апреле. Апрель имеет 30 дней, поэтому диапазон: с 1 по 30 апреля. Это про дату публикации, используем таблицу videos.
SQL: SELECT COUNT(*) FROM videos WHERE DATE(video_created_at) >= DATE '2025-04-01' AND DATE(video_created_at) <= DATE '2025-04-30';

Пример 20: Вопрос про месяц с 30 днями (июнь)
Вопрос: "Сколько видео опубликовано в июне 2025?"
Контекст: Пользователь спрашивает про количество видео, опубликованных в июне. Июнь имеет 30 дней, поэтому диапазон: с 1 по 30 июня. Это про дату публикации, используем таблицу videos.
SQL: SELECT COUNT(*) FROM videos WHERE DATE(video_created_at) >= DATE '2025-06-01' AND DATE(video_created_at) <= DATE '2025-06-30';

Пример 21: Вопрос про месяц с 30 днями (сентябрь)
Вопрос: "Сколько видео опубликовано в сентябре 2025?"
Контекст: Пользователь спрашивает про количество видео, опубликованных в сентябре. Сентябрь имеет 30 дней, поэтому диапазон: с 1 по 30 сентября. Это про дату публикации, используем таблицу videos.
SQL: SELECT COUNT(*) FROM videos WHERE DATE(video_created_at) >= DATE '2025-09-01' AND DATE(video_created_at) <= DATE '2025-09-30';

Пример 22: Вопрос про месяц с 31 днем (март)
Вопрос: "Сколько видео опубликовано в марте 2025?"
Контекст: Пользователь спрашивает про количество видео, опубликованных в марте. Март имеет 31 день, поэтому диапазон: с 1 по 31 марта. Это про дату публикации, используем таблицу videos.
SQL: SELECT COUNT(*) FROM videos WHERE DATE(video_created_at) >= DATE '2025-03-01' AND DATE(video_created_at) <= DATE '2025-03-31';

Пример 23: Вопрос про месяц с 31 днем (май)
Вопрос: "Сколько видео опубликовано в мае 2025?"
Контекст: Пользователь спрашивает про количество видео, опубликованных в мае. Май имеет 31 день, поэтому диапазон: с 1 по 31 мая. Это про дату публикации, используем таблицу videos.
SQL: SELECT COUNT(*) FROM videos WHERE DATE(video_created_at) >= DATE '2025-05-01' AND DATE(video_created_at) <= DATE '2025-05-31';

Пример 24: Вопрос про прирост за месяц с 30 днями
Вопрос: "На сколько просмотров выросли все видео в апреле 2025?"
Контекст: Пользователь спрашивает про прирост просмотров за апрель. Это про динамику, используем таблицу video_snapshots. Апрель имеет 30 дней, поэтому диапазон: с 1 по 30 апреля.
SQL: SELECT SUM(delta_views_count) FROM video_snapshots WHERE DATE(created_at) >= DATE '2025-04-01' AND DATE(created_at) <= DATE '2025-04-30';

Пример 25: Вопрос про прирост за февраль в високосном году
Вопрос: "На сколько просмотров выросли все видео в феврале 2024?"
Контекст: Пользователь спрашивает про прирост просмотров за февраль 2024. Это про динамику, используем таблицу video_snapshots. 2024 год високосный, поэтому февраль имеет 29 дней. Диапазон: с 1 по 29 февраля.
SQL: SELECT SUM(delta_views_count) FROM video_snapshots WHERE DATE(created_at) >= DATE '2024-02-01' AND DATE(created_at) <= DATE '2024-02-29';

Пример 26: Вопрос про месяц с 31 днем (июль)
Вопрос: "Сколько видео опубликовано в июле 2025?"
Контекст: Пользователь спрашивает про количество видео, опубликованных в июле. Июль имеет 31 день, поэтому диапазон: с 1 по 31 июля. Это про дату публикации, используем таблицу videos.
SQL: SELECT COUNT(*) FROM videos WHERE DATE(video_created_at) >= DATE '2025-07-01' AND DATE(video_created_at) <= DATE '2025-07-31';

Пример 27: Вопрос про месяц с 31 днем (август)
Вопрос: "Сколько видео опубликовано в августе 2025?"
Контекст: Пользователь спрашивает про количество видео, опубликованных в августе. Август имеет 31 день, поэтому диапазон: с 1 по 31 августа. Это про дату публикации, используем таблицу videos.
SQL: SELECT COUNT(*) FROM videos WHERE DATE(video_created_at) >= DATE '2025-08-01' AND DATE(video_created_at) <= DATE '2025-08-31';

Пример 28: Вопрос про месяц с 31 днем (октябрь)
Вопрос: "Сколько видео опубликовано в октябре 2025?"
Контекст: Пользователь спрашивает про количество видео, опубликованных в октябре. Октябрь имеет 31 день, поэтому диапазон: с 1 по 31 октября. Это про дату публикации, используем таблицу videos.
SQL: SELECT COUNT(*) FROM videos WHERE DATE(video_created_at) >= DATE '2025-10-01' AND DATE(video_created_at) <= DATE '2025-10-31';

Пример 29: Вопрос про месяц с 31 днем (декабрь)
Вопрос: "Сколько видео опубликовано в декабре 2025?"
Контекст: Пользователь спрашивает про количество видео, опубликованных в декабре. Декабрь имеет 31 день, поэтому диапазон: с 1 по 31 декабря. Это про дату публикации, используем таблицу videos.
SQL: SELECT COUNT(*) FROM videos WHERE DATE(video_created_at) >= DATE '2025-12-01' AND DATE(video_created_at) <= DATE '2025-12-31';

Пример 30: Вопрос про прирост за месяц с 31 днем (июль)
Вопрос: "На сколько просмотров выросли все видео в июле 2025?"
Контекст: Пользователь спрашивает про прирост просмотров за июль. Это про динамику, используем таблицу video_snapshots. Июль имеет 31 день, поэтому диапазон: с 1 по 31 июля.
SQL: SELECT SUM(delta_views_count) FROM video_snapshots WHERE DATE(created_at) >= DATE '2025-07-01' AND DATE(created_at) <= DATE '2025-07-31';

Пример 31: Вопрос про прирост за месяц с 30 днями (июнь)
Вопрос: "На сколько просмотров выросли все видео в июне 2025?"
Контекст: Пользователь спрашивает про прирост просмотров за июнь. Это про динамику, используем таблицу video_snapshots. Июнь имеет 30 дней, поэтому диапазон: с 1 по 30 июня.
SQL: SELECT SUM(delta_views_count) FROM video_snapshots WHERE DATE(created_at) >= DATE '2025-06-01' AND DATE(created_at) <= DATE '2025-06-30';

ВАЖНЫЕ ПРИНЦИПЫ ПОНИМАНИЯ:

1. Анализируй намерение пользователя, а не ищи точные совпадения слов
2. Понимай контекст вопроса: что именно хочет узнать пользователь?
3. Определяй, какая таблица нужна на основе семантики вопроса:
   - Итоговые значения, текущее состояние → таблица videos
   - Изменения, динамика, прирост → таблица video_snapshots
4. Для дат понимай любые форматы русского языка и преобразуй их в SQL DATE
5. ВСЕГДА правильно рассчитывай диапазоны дат:
   - Учитывай количество дней в каждом месяце (28/29/30/31)
   - Правильно определяй високосные годы (делится на 4, но не на 100, кроме делящихся на 400)
   - Февраль: 28 дней в невисокосном году, 29 дней в високосном
   - Месяцы с 31 днем: январь, март, май, июль, август, октябрь, декабрь
   - Месяцы с 30 днями: апрель, июнь, сентябрь, ноябрь
6. Для ID креаторов извлекай значение из контекста вопроса, сохраняя его точно как указано
7. Для чисел понимай пробелы как разделители тысяч

ТРЕБОВАНИЯ К ОТВЕТУ:
- Всегда возвращай ТОЛЬКО SQL запрос
- НЕ добавляй объяснения, комментарии или дополнительный текст
- НЕ используй markdown форматирование
- Если вопрос неоднозначен, выбирай наиболее вероятную интерпретацию на основе контекста

Теперь преобразуй следующий вопрос в SQL запрос. Верни ТОЛЬКО SQL, без дополнительного текста:"""


class SQLQueryGenerator:
    """Генератор SQL запросов из естественного языка с помощью GigaChat."""

    def __init__(self, credentials: str, scope: str = "GIGACHAT_API_PERS"):
        """
        Инициализация генератора.

        Args:
            credentials: Authorization key (токен авторизации) GigaChat
            scope: Область действия API (GIGACHAT_API_PERS, GIGACHAT_API_B2B, GIGACHAT_API_CORP)
        """
        self.credentials = credentials
        self.scope = scope
        self._client = None

    def _get_client(self) -> GigaChat:
        """Получает или создает клиент GigaChat."""
        if self._client is None:
            self._client = GigaChat(
                credentials=self.credentials,
                scope=self.scope,
                verify_ssl_certs=False
            )
        return self._client

    def _normalize_query(self, query: str) -> str:
        """
        Минимальная нормализация вопроса - только базовая очистка.
        Вся обработка форматов дат, ID креаторов и понимание вопросов
        выполняется нейросетью GigaChat на основе детального промпта.

        Args:
            query: Исходный вопрос

        Returns:
            Нормализованный вопрос (только базовая очистка)
        """
        # Убираем лишние пробелы
        query = ' '.join(query.split())

        # Нормализуем числа с пробелами (100 000 -> 100000)
        # Это единственная предобработка, остальное делает GigaChat
        # Ищем паттерны типа "100 000", "1 000 000" и т.д.
        query = re.sub(r'(\d+)\s+(\d+)', r'\1\2', query)

        return query.strip()

    async def generate_sql(self, user_query: str) -> str:
        """
        Генерирует SQL запрос из вопроса на естественном языке.

        Args:
            user_query: Вопрос пользователя на русском языке

        Returns:
            SQL запрос в виде строки

        Raises:
            Exception: При ошибке обращения к API или генерации запроса
        """
        try:
            # Нормализуем вопрос
            normalized_query = self._normalize_query(user_query)
            logger.info(
                "Генерация SQL для вопроса",
                original_query=user_query[:200],
                normalized_query=normalized_query[:200]
            )

            # Формируем полный промпт с четкой инструкцией
            full_prompt = f"""{SYSTEM_PROMPT}

Вопрос пользователя: {normalized_query}

Верни ТОЛЬКО SQL запрос, без объяснений:"""

            # Выполняем запрос в отдельном потоке, так как GigaChat синхронный
            client = self._get_client()

            # Используем asyncio.to_thread для выполнения синхронного кода
            response = await asyncio.to_thread(
                client.chat,
                full_prompt
            )

            logger.debug(
                "Ответ от GigaChat получен",
                response_type=type(response).__name__,
                has_choices=hasattr(response, 'choices') and len(response.choices) > 0 if hasattr(response, 'choices') else False
            )

            # Извлекаем текст ответа
            text = None
            if hasattr(response, 'choices') and len(response.choices) > 0:
                text = response.choices[0].message.content.strip()
            elif hasattr(response, 'content'):
                text = response.content.strip()
            elif isinstance(response, str):
                text = response.strip()
            else:
                # Пробуем получить текст из различных атрибутов
                for attr in ['text', 'message', 'result']:
                    if hasattr(response, attr):
                        value = getattr(response, attr)
                        if isinstance(value, str):
                            text = value.strip()
                            break
                        elif hasattr(value, 'content'):
                            text = value.content.strip()
                            break

                if not text:
                    raise Exception(f"Неожиданный формат ответа от GigaChat: {type(response)}, атрибуты: {dir(response)}")

            logger.debug(
                "Извлеченный текст из ответа",
                text_preview=text[:200] if text else None,
                text_length=len(text) if text else 0
            )

            # Очищаем ответ от markdown форматирования
            if "```sql" in text:
                # Извлекаем SQL из блока кода
                start = text.find("```sql") + 6
                end = text.find("```", start)
                if end != -1:
                    text = text[start:end].strip()
                else:
                    text = text.replace("```sql", "").replace("```", "").strip()
            elif "```" in text:
                # Убираем любые блоки кода
                text = re.sub(r'```[a-z]*\n?', '', text)
                text = text.replace("```", "").strip()

            # Убираем лишние пробелы и переносы строк, но сохраняем структуру SQL
            lines = [line.strip() for line in text.split('\n') if line.strip()]
            text = ' '.join(lines)

            # Убираем возможные префиксы типа "SQL:", "Запрос:" и т.д.
            prefixes = [
                "SQL:", "sql:", "Запрос:", "запрос:", "Ответ:", "ответ:",
                "Вот SQL запрос:", "SQL запрос:", "Запрос SQL:",
                "SELECT", "select"  # На случай если есть текст перед SELECT
            ]
            for prefix in prefixes:
                if text.startswith(prefix):
                    text = text[len(prefix):].strip()
                    break

            # Проверяем, что это похоже на SQL запрос
            text_upper = text.upper().strip()
            if not text_upper.startswith("SELECT"):
                # Пробуем найти SELECT в тексте
                select_pos = text_upper.find("SELECT")
                if select_pos != -1:
                    text = text[select_pos:].strip()
                    # Убираем возможный текст после SQL (объяснения)
                    # Ищем конец SQL запроса по точке с запятой или ключевым словам
                    semicolon_pos = text.find(';')
                    if semicolon_pos != -1:
                        text = text[:semicolon_pos + 1]
                    else:
                        # Пробуем найти конец по ключевым словам, которые могут быть после SQL
                        end_markers = ['\n\n', 'Этот запрос', 'Запрос', 'SQL', 'SELECT']
                        for marker in end_markers:
                            if marker in text and text.find(marker) > len(text) * 0.3:
                                # Если маркер найден далеко от начала, обрезаем
                                marker_pos = text.find(marker, len(text) // 2)
                                if marker_pos != -1:
                                    text = text[:marker_pos].strip()
                                    break
                else:
                    logger.error(
                        "Ответ не содержит SQL запрос",
                        response_text=text[:200] if text else None,
                        response_length=len(text) if text else 0,
                        normalized_query=normalized_query[:200]
                    )
                    raise Exception(f"Ответ не содержит SQL запрос. Получено: {text[:100]}...")

            # Убираем точку с запятой в конце (она не обязательна для выполнения)
            text = text.rstrip(';').strip()

            # Финальная проверка
            if not text or len(text) < 10:
                raise Exception("Пустой или слишком короткий ответ от GigaChat")

            if not text.upper().startswith("SELECT"):
                raise Exception(f"Ответ не начинается с SELECT: {text[:50]}")

            logger.info(
                "SQL запрос успешно сгенерирован",
                sql_query=text[:500] if len(text) > 500 else text,
                query_length=len(text),
                normalized_query=normalized_query[:200]
            )
            return text

        except Exception as e:
            logger.exception(
                "Ошибка при обращении к GigaChat API",
                user_query=user_query[:200],
                normalized_query=normalized_query[:200] if 'normalized_query' in locals() else None,
                error=str(e),
                error_type=type(e).__name__
            )
            raise Exception(f"Ошибка при обращении к GigaChat API: {e}")


def create_generator() -> Optional[SQLQueryGenerator]:
    """
    Создает генератор SQL запросов из переменных окружения.

    Returns:
        SQLQueryGenerator или None, если переменные окружения не настроены
    """
    credentials = os.getenv("GIGACHAT_CREDENTIALS")
    scope = os.getenv("GIGACHAT_SCOPE", "GIGACHAT_API_PERS")

    if not credentials:
        return None

    return SQLQueryGenerator(credentials, scope)
